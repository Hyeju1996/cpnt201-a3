"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = resolveDefaultsAtRules;
exports.elementSelectorParser = void 0;

var _postcss = _interopRequireDefault(require("postcss"));

var _postcssSelectorParser = _interopRequireDefault(require("postcss-selector-parser"));

var _featureFlags = require("../featureFlags");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var getNode = {
  id: function id(node) {
    return _postcssSelectorParser["default"].attribute({
      attribute: 'id',
      operator: '=',
      value: node.value,
      quoteMark: '"'
    });
  }
};

function minimumImpactSelector(nodes) {
  var rest = nodes.filter(function (node) {
    // Keep non-pseudo nodes
    if (node.type !== 'pseudo') return true; // Keep pseudo nodes that have subnodes
    // E.g.: `:not()` contains subnodes inside the parentheses

    if (node.nodes.length > 0) return true; // Keep pseudo `elements`
    // This implicitly means that we ignore pseudo `classes`

    return node.value.startsWith('::') || [':before', ':after', ':first-line', ':first-letter'].includes(node.value);
  }).reverse();
  var searchFor = new Set(['tag', 'class', 'id', 'attribute']);
  var splitPointIdx = rest.findIndex(function (n) {
    return searchFor.has(n.type);
  });
  if (splitPointIdx === -1) return rest.reverse().join('').trim();
  var node1 = rest[splitPointIdx];
  var bestNode = getNode[node1.type] ? getNode[node1.type](node1) : node1;
  rest = rest.slice(0, splitPointIdx);
  var combinatorIdx = rest.findIndex(function (n) {
    return n.type === 'combinator' && n.value === '>';
  });

  if (combinatorIdx !== -1) {
    rest.splice(0, combinatorIdx);
    rest.unshift(_postcssSelectorParser["default"].universal());
  }

  return [bestNode].concat(_toConsumableArray(rest.reverse())).join('').trim();
}

var elementSelectorParser = (0, _postcssSelectorParser)["default"](function (selectors) {
  return selectors.map(function (s) {
    var nodes = s.split(function (n) {
      return n.type === 'combinator' && n.value === ' ';
    }).pop();
    return minimumImpactSelector(nodes);
  });
});
exports.elementSelectorParser = elementSelectorParser;
var cache = new Map();

function extractElementSelector(selector) {
  if (!cache.has(selector)) {
    cache.set(selector, elementSelectorParser.transformSync(selector));
  }

  return cache.get(selector);
}

function resolveDefaultsAtRules(_ref) {
  var tailwindConfig = _ref.tailwindConfig;
  return function (root) {
    var variableNodeMap = new Map();
    /** @type {Set<import('postcss').AtRule>} */

    var universals = new Set();
    root.walkAtRules('defaults', function (rule) {
      if (rule.nodes && rule.nodes.length > 0) {
        universals.add(rule);
        return;
      }

      var variable = rule.params;

      if (!variableNodeMap.has(variable)) {
        variableNodeMap.set(variable, new Set());
      }

      variableNodeMap.get(variable).add(rule.parent);
      rule.remove();
    });
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = universals[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var universal = _step.value;

        /** @type {Map<string, Set<string>>} */
        var selectorGroups = new Map();
        var ref;
        var rules = (ref = variableNodeMap.get(universal.params)) !== null && ref !== void 0 ? ref : [];
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = rules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var rule = _step2.value;
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
              for (var _iterator4 = extractElementSelector(rule.selector)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var selector = _step4.value;
                // If selector contains a vendor prefix after a pseudo element or class,
                // we consider them separately because merging the declarations into
                // a single rule will cause browsers that do not understand the
                // vendor prefix to throw out the whole rule
                var selectorGroupName = selector.includes(':-') || selector.includes('::-') ? selector : '__DEFAULT__';
                var ref1;

                var _selectors = (ref1 = selectorGroups.get(selectorGroupName)) !== null && ref1 !== void 0 ? ref1 : new Set();

                selectorGroups.set(selectorGroupName, _selectors);

                _selectors.add(selector);
              }
            } catch (err) {
              _didIteratorError4 = true;
              _iteratorError4 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                  _iterator4["return"]();
                }
              } finally {
                if (_didIteratorError4) {
                  throw _iteratorError4;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        if ((0, _featureFlags).flagEnabled(tailwindConfig, 'optimizeUniversalDefaults')) {
          if (selectorGroups.size === 0) {
            universal.remove();
            continue;
          }

          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = selectorGroups[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _step3$value = _slicedToArray(_step3.value, 2),
                  selectors = _step3$value[1];

              var universalRule = _postcss["default"].rule();

              universalRule.selectors = _toConsumableArray(selectors);
              universalRule.append(universal.nodes.map(function (node) {
                return node.clone();
              }));
              universal.before(universalRule);
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        } else {
          var _universalRule = _postcss["default"].rule();

          _universalRule.selectors = ['*', '::before', '::after'];

          _universalRule.append(universal.nodes);

          universal.before(_universalRule);
        }

        universal.remove();
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  };
}