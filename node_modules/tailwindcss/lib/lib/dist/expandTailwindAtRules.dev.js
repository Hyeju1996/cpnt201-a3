"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = expandTailwindAtRules;

var _quickLru = _interopRequireDefault(require("quick-lru"));

var sharedState = _interopRequireWildcard(require("./sharedState"));

var _generateRules = require("./generateRules");

var _bigSign = _interopRequireDefault(require("../util/bigSign"));

var _log = _interopRequireDefault(require("../util/log"));

var _cloneNodes = _interopRequireDefault(require("../util/cloneNodes"));

var _defaultExtractor = require("./defaultExtractor");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj["default"] = obj;
    return newObj;
  }
}

var env = sharedState.env;
var builtInExtractors = {
  DEFAULT: _defaultExtractor.defaultExtractor
};
var builtInTransformers = {
  DEFAULT: function DEFAULT(content) {
    return content;
  },
  svelte: function svelte(content) {
    return content.replace(/(?:^|\s)class:/g, ' ');
  }
};

function getExtractor(tailwindConfig, fileExtension) {
  var extractors = tailwindConfig.content.extract;
  return extractors[fileExtension] || extractors.DEFAULT || builtInExtractors[fileExtension] || builtInExtractors.DEFAULT;
}

function getTransformer(tailwindConfig, fileExtension) {
  var transformers = tailwindConfig.content.transform;
  return transformers[fileExtension] || transformers.DEFAULT || builtInTransformers[fileExtension] || builtInTransformers.DEFAULT;
}

var extractorCache = new WeakMap(); // Scans template contents for possible classes. This is a hot path on initial build but
// not too important for subsequent builds. The faster the better though â€” if we can speed
// up these regexes by 50% that could cut initial build time by like 20%.

function getClassCandidates(content, extractor, candidates, seen) {
  if (!extractorCache.has(extractor)) {
    extractorCache.set(extractor, new _quickLru["default"]({
      maxSize: 25000
    }));
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = content.split('\n')[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var line = _step.value;
      line = line.trim();

      if (seen.has(line)) {
        continue;
      }

      seen.add(line);

      if (extractorCache.get(extractor).has(line)) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = extractorCache.get(extractor).get(line)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var match = _step2.value;
            candidates.add(match);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      } else {
        var extractorMatches = extractor(line).filter(function (s) {
          return s !== '!*';
        });
        var lineMatchesSet = new Set(extractorMatches);
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = lineMatchesSet[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _match = _step3.value;
            candidates.add(_match);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        extractorCache.get(extractor).set(line, lineMatchesSet);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

function buildStylesheet(rules, context) {
  var sortedRules = rules.sort(function (_ref, _ref2) {
    var _ref3 = _slicedToArray(_ref, 1),
        a = _ref3[0];

    var _ref4 = _slicedToArray(_ref2, 1),
        z = _ref4[0];

    return (0, _bigSign)["default"](a - z);
  });
  var returnValue = {
    base: new Set(),
    defaults: new Set(),
    components: new Set(),
    utilities: new Set(),
    variants: new Set(),
    // All the CSS that is not Tailwind related can be put in this bucket. This
    // will make it easier to later use this information when we want to
    // `@apply` for example. The main reason we do this here is because we
    // still need to make sure the order is correct. Last but not least, we
    // will make sure to always re-inject this section into the css, even if
    // certain rules were not used. This means that it will look like a no-op
    // from the user's perspective, but we gathered all the useful information
    // we need.
    user: new Set()
  };
  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = sortedRules[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var _step4$value = _slicedToArray(_step4.value, 2),
          sort = _step4$value[0],
          rule = _step4$value[1];

      if (sort >= context.minimumScreen) {
        returnValue.variants.add(rule);
        continue;
      }

      if (sort & context.layerOrder.base) {
        returnValue.base.add(rule);
        continue;
      }

      if (sort & context.layerOrder.defaults) {
        returnValue.defaults.add(rule);
        continue;
      }

      if (sort & context.layerOrder.components) {
        returnValue.components.add(rule);
        continue;
      }

      if (sort & context.layerOrder.utilities) {
        returnValue.utilities.add(rule);
        continue;
      }

      if (sort & context.layerOrder.user) {
        returnValue.user.add(rule);
        continue;
      }
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
        _iterator4["return"]();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  return returnValue;
}

function expandTailwindAtRules(context) {
  return function (root) {
    var layerNodes = {
      base: null,
      components: null,
      utilities: null,
      variants: null
    };
    root.walkAtRules(function (rule) {
      // Make sure this file contains Tailwind directives. If not, we can save
      // a lot of work and bail early. Also we don't have to register our touch
      // file as a dependency since the output of this CSS does not depend on
      // the source of any templates. Think Vue <style> blocks for example.
      if (rule.name === 'tailwind') {
        if (Object.keys(layerNodes).includes(rule.params)) {
          layerNodes[rule.params] = rule;
        }
      }
    });

    if (Object.values(layerNodes).every(function (n) {
      return n === null;
    })) {
      return root;
    } // ---
    // Find potential rules in changed files


    var candidates = new Set([sharedState.NOT_ON_DEMAND]);
    var seen = new Set();
    env.DEBUG && console.time('Reading changed files');
    var _iteratorNormalCompletion5 = true;
    var _didIteratorError5 = false;
    var _iteratorError5 = undefined;

    try {
      for (var _iterator5 = context.changedContent[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
        var _step5$value = _step5.value,
            content = _step5$value.content,
            extension = _step5$value.extension;
        var transformer = getTransformer(context.tailwindConfig, extension);
        var extractor = getExtractor(context.tailwindConfig, extension);
        getClassCandidates(transformer(content), extractor, candidates, seen);
      }
    } catch (err) {
      _didIteratorError5 = true;
      _iteratorError5 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
          _iterator5["return"]();
        }
      } finally {
        if (_didIteratorError5) {
          throw _iteratorError5;
        }
      }
    }

    env.DEBUG && console.timeEnd('Reading changed files'); // ---
    // Generate the actual CSS

    var classCacheCount = context.classCache.size;
    env.DEBUG && console.time('Generate rules');
    var rules = (0, _generateRules).generateRules(candidates, context);
    env.DEBUG && console.timeEnd('Generate rules'); // We only ever add to the classCache, so if it didn't grow, there is nothing new.

    env.DEBUG && console.time('Build stylesheet');

    if (context.stylesheetCache === null || context.classCache.size !== classCacheCount) {
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = rules[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var rule = _step6.value;
          context.ruleCache.add(rule);
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
            _iterator6["return"]();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      context.stylesheetCache = buildStylesheet(_toConsumableArray(context.ruleCache), context);
    }

    env.DEBUG && console.timeEnd('Build stylesheet');
    var _context$stylesheetCa = context.stylesheetCache,
        defaultNodes = _context$stylesheetCa.defaults,
        baseNodes = _context$stylesheetCa.base,
        componentNodes = _context$stylesheetCa.components,
        utilityNodes = _context$stylesheetCa.utilities,
        screenNodes = _context$stylesheetCa.variants; // ---
    // Replace any Tailwind directives with generated CSS

    if (layerNodes.base) {
      layerNodes.base.before((0, _cloneNodes)["default"]([].concat(_toConsumableArray(baseNodes), _toConsumableArray(defaultNodes)), layerNodes.base.source));
      layerNodes.base.remove();
    }

    if (layerNodes.components) {
      layerNodes.components.before((0, _cloneNodes)["default"](_toConsumableArray(componentNodes), layerNodes.components.source));
      layerNodes.components.remove();
    }

    if (layerNodes.utilities) {
      layerNodes.utilities.before((0, _cloneNodes)["default"](_toConsumableArray(utilityNodes), layerNodes.utilities.source));
      layerNodes.utilities.remove();
    } // We do post-filtering to not alter the emitted order of the variants


    var variantNodes = Array.from(screenNodes).filter(function (node) {
      var ref;
      var parentLayer = (ref = node.raws.tailwind) === null || ref === void 0 ? void 0 : ref.parentLayer;

      if (parentLayer === 'components') {
        return layerNodes.components !== null;
      }

      if (parentLayer === 'utilities') {
        return layerNodes.utilities !== null;
      }

      return true;
    });

    if (layerNodes.variants) {
      layerNodes.variants.before((0, _cloneNodes)["default"](variantNodes, layerNodes.variants.source));
      layerNodes.variants.remove();
    } else if (variantNodes.length > 0) {
      root.append((0, _cloneNodes)["default"](variantNodes, root.source));
    } // If we've got a utility layer and no utilities are generated there's likely something wrong


    var hasUtilityVariants = variantNodes.some(function (node) {
      var ref;
      return ((ref = node.raws.tailwind) === null || ref === void 0 ? void 0 : ref.parentLayer) === 'utilities';
    });

    if (layerNodes.utilities && utilityNodes.size === 0 && !hasUtilityVariants) {
      _log["default"].warn('content-problems', ['No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.', 'https://tailwindcss.com/docs/content-configuration']);
    } // ---


    if (env.DEBUG) {
      console.log('Potential classes: ', candidates.size);
      console.log('Active contexts: ', sharedState.contextSourcesMap.size);
    } // Clear the cache for the changed files


    context.changedContent = []; // Cleanup any leftover @layer atrules

    root.walkAtRules('layer', function (rule) {
      if (Object.keys(layerNodes).includes(rule.params)) {
        rule.remove();
      }
    });
  };
}