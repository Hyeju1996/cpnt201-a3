"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateAllClasses = updateAllClasses;
exports.asValue = asValue;
exports.asColor = asColor;
exports.asLookupValue = asLookupValue;
exports.coerceValue = coerceValue;

var _postcssSelectorParser = _interopRequireDefault(require("postcss-selector-parser"));

var _escapeCommas = _interopRequireDefault(require("./escapeCommas"));

var _withAlphaVariable = require("./withAlphaVariable");

var _dataTypes = require("./dataTypes");

var _negateValue = _interopRequireDefault(require("./negateValue"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function updateAllClasses(selectors1, updateClass) {
  var parser = (0, _postcssSelectorParser)["default"](function (selectors) {
    selectors.walkClasses(function (sel) {
      var updatedClass = updateClass(sel.value);
      sel.value = updatedClass;

      if (sel.raws && sel.raws.value) {
        sel.raws.value = (0, _escapeCommas)["default"](sel.raws.value);
      }
    });
  });
  var result = parser.processSync(selectors1);
  return result;
}

function resolveArbitraryValue(modifier, validate) {
  if (!isArbitraryValue(modifier)) {
    return undefined;
  }

  var value = modifier.slice(1, -1);

  if (!validate(value)) {
    return undefined;
  }

  return (0, _dataTypes).normalize(value);
}

function asNegativeValue(modifier) {
  var lookup = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var validate = arguments.length > 2 ? arguments[2] : undefined;
  var positiveValue = lookup[modifier];

  if (positiveValue !== undefined) {
    return (0, _negateValue)["default"](positiveValue);
  }

  if (isArbitraryValue(modifier)) {
    var resolved = resolveArbitraryValue(modifier, validate);

    if (resolved === undefined) {
      return undefined;
    }

    return (0, _negateValue)["default"](resolved);
  }
}

function asValue(modifier) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref$validate = _ref.validate,
      validate = _ref$validate === void 0 ? function () {
    return true;
  } : _ref$validate;

  var ref;
  var value = (ref = options.values) === null || ref === void 0 ? void 0 : ref[modifier];

  if (value !== undefined) {
    return value;
  }

  if (options.supportsNegativeValues && modifier.startsWith('-')) {
    return asNegativeValue(modifier.slice(1), options.values, validate);
  }

  return resolveArbitraryValue(modifier, validate);
}

function isArbitraryValue(input) {
  return input.startsWith('[') && input.endsWith(']');
}

function splitAlpha(modifier) {
  var slashIdx = modifier.lastIndexOf('/');

  if (slashIdx === -1 || slashIdx === modifier.length - 1) {
    return [modifier];
  }

  return [modifier.slice(0, slashIdx), modifier.slice(slashIdx + 1)];
}

function asColor(modifier) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$tailwindConfig = _ref2.tailwindConfig,
      tailwindConfig = _ref2$tailwindConfig === void 0 ? {} : _ref2$tailwindConfig;

  var ref;

  if (((ref = options.values) === null || ref === void 0 ? void 0 : ref[modifier]) !== undefined) {
    var ref1;
    return (ref1 = options.values) === null || ref1 === void 0 ? void 0 : ref1[modifier];
  }

  var _splitAlpha = splitAlpha(modifier),
      _splitAlpha2 = _slicedToArray(_splitAlpha, 2),
      color = _splitAlpha2[0],
      alpha = _splitAlpha2[1];

  if (alpha !== undefined) {
    var ref2, ref3, ref4;
    var ref5;
    var normalizedColor = (ref5 = (ref2 = options.values) === null || ref2 === void 0 ? void 0 : ref2[color]) !== null && ref5 !== void 0 ? ref5 : isArbitraryValue(color) ? color.slice(1, -1) : undefined;

    if (normalizedColor === undefined) {
      return undefined;
    }

    if (isArbitraryValue(alpha)) {
      return (0, _withAlphaVariable).withAlphaValue(normalizedColor, alpha.slice(1, -1));
    }

    if (((ref3 = tailwindConfig.theme) === null || ref3 === void 0 ? void 0 : (ref4 = ref3.opacity) === null || ref4 === void 0 ? void 0 : ref4[alpha]) === undefined) {
      return undefined;
    }

    return (0, _withAlphaVariable).withAlphaValue(normalizedColor, tailwindConfig.theme.opacity[alpha]);
  }

  return asValue(modifier, options, {
    validate: _dataTypes.color
  });
}

function asLookupValue(modifier) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var ref;
  return (ref = options.values) === null || ref === void 0 ? void 0 : ref[modifier];
}

function guess(validate) {
  return function (modifier, options) {
    return asValue(modifier, options, {
      validate: validate
    });
  };
}

var typeMap = {
  any: asValue,
  color: asColor,
  url: guess(_dataTypes.url),
  image: guess(_dataTypes.image),
  length: guess(_dataTypes.length),
  percentage: guess(_dataTypes.percentage),
  position: guess(_dataTypes.position),
  lookup: asLookupValue,
  'generic-name': guess(_dataTypes.genericName),
  'family-name': guess(_dataTypes.familyName),
  number: guess(_dataTypes.number),
  'line-width': guess(_dataTypes.lineWidth),
  'absolute-size': guess(_dataTypes.absoluteSize),
  'relative-size': guess(_dataTypes.relativeSize),
  shadow: guess(_dataTypes.shadow)
};
var supportedTypes = Object.keys(typeMap);

function splitAtFirst(input, delim) {
  var idx = input.indexOf(delim);
  if (idx === -1) return [undefined, input];
  return [input.slice(0, idx), input.slice(idx + 1)];
}

function coerceValue(types, modifier, options, tailwindConfig) {
  if (isArbitraryValue(modifier)) {
    var arbitraryValue = modifier.slice(1, -1);

    var _splitAtFirst = splitAtFirst(arbitraryValue, ':'),
        _splitAtFirst2 = _slicedToArray(_splitAtFirst, 2),
        explicitType = _splitAtFirst2[0],
        value = _splitAtFirst2[1]; // It could be that this resolves to `url(https` which is not a valid
    // identifier. We currently only support "simple" words with dashes or
    // underscores. E.g.: family-name


    if (!/^[\w-_]+$/g.test(explicitType)) {
      value = arbitraryValue;
    } else if (explicitType !== undefined && !supportedTypes.includes(explicitType)) {
      return [];
    }

    if (value.length > 0 && supportedTypes.includes(explicitType)) {
      return [asValue("[".concat(value, "]"), options), explicitType];
    }
  } // Find first matching type


  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = [].concat(types)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var type = _step.value;
      var result = typeMap[type](modifier, options, {
        tailwindConfig: tailwindConfig
      });
      if (result !== undefined) return [result, type];
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return [];
}