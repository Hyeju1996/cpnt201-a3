"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatVariantSelector = formatVariantSelector;
exports.finalizeSelector = finalizeSelector;
exports.selectorFunctions = void 0;

var _postcssSelectorParser = _interopRequireDefault(require("postcss-selector-parser"));

var _unesc = _interopRequireDefault(require("postcss-selector-parser/dist/util/unesc"));

var _escapeClassName = _interopRequireDefault(require("../util/escapeClassName"));

var _prefixSelector = _interopRequireDefault(require("../util/prefixSelector"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var MERGE = ':merge';
var PARENT = '&';
var selectorFunctions = new Set([MERGE]);
exports.selectorFunctions = selectorFunctions;

function formatVariantSelector(current) {
  for (var _len = arguments.length, others = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    others[_key - 1] = arguments[_key];
  }

  for (var _i = 0, _others = others; _i < _others.length; _i++) {
    var other = _others[_i];
    var incomingValue = resolveFunctionArgument(other, MERGE);

    if (incomingValue !== null) {
      var existingValue = resolveFunctionArgument(current, MERGE, incomingValue);

      if (existingValue !== null) {
        var existingTarget = "".concat(MERGE, "(").concat(incomingValue, ")");
        var splitIdx = other.indexOf(existingTarget);
        var addition = other.slice(splitIdx + existingTarget.length).split(' ')[0];
        current = current.replace(existingTarget, existingTarget + addition);
        continue;
      }
    }

    current = other.replace(PARENT, current);
  }

  return current;
}

function finalizeSelector(format, _ref) {
  var selector1 = _ref.selector,
      candidate = _ref.candidate,
      context = _ref.context;
  var ref, ref1;
  var ref2;
  var separator = (ref2 = context === null || context === void 0 ? void 0 : (ref = context.tailwindConfig) === null || ref === void 0 ? void 0 : ref.separator) !== null && ref2 !== void 0 ? ref2 : ':'; // Split by the separator, but ignore the separator inside square brackets:
  //
  // E.g.: dark:lg:hover:[paint-order:markers]
  //           ┬  ┬     ┬            ┬
  //           │  │     │            ╰── We will not split here
  //           ╰──┴─────┴─────────────── We will split here
  //

  var splitter = new RegExp("\\".concat(separator, "(?![^[]*\\])"));
  var base = candidate.split(splitter).pop();

  if (context === null || context === void 0 ? void 0 : (ref1 = context.tailwindConfig) === null || ref1 === void 0 ? void 0 : ref1.prefix) {
    format = (0, _prefixSelector)["default"](context.tailwindConfig.prefix, format);
  }

  format = format.replace(PARENT, ".".concat((0, _escapeClassName)["default"](candidate))); // Normalize escaped classes, e.g.:
  //
  // The idea would be to replace the escaped `base` in the selector with the
  // `format`. However, in css you can escape the same selector in a few
  // different ways. This would result in different strings and therefore we
  // can't replace it properly.
  //
  //               base: bg-[rgb(255,0,0)]
  //   base in selector: bg-\\[rgb\\(255\\,0\\,0\\)\\]
  //       escaped base: bg-\\[rgb\\(255\\2c 0\\2c 0\\)\\]
  //

  selector1 = (0, _postcssSelectorParser)["default"](function (selectors) {
    return selectors.walkClasses(function (node) {
      if (node.raws && node.value.includes(base)) {
        node.raws.value = (0, _escapeClassName)["default"]((0, _unesc)["default"](node.raws.value));
      }

      return node;
    });
  }).processSync(selector1); // We can safely replace the escaped base now, since the `base` section is
  // now in a normalized escaped value.

  selector1 = selector1.replace(".".concat((0, _escapeClassName)["default"](base)), format); // Remove unnecessary pseudo selectors that we used as placeholders

  return (0, _postcssSelectorParser)["default"](function (selectors) {
    return selectors.map(function (selector2) {
      selector2.walkPseudos(function (p) {
        if (selectorFunctions.has(p.value)) {
          p.replaceWith(p.nodes);
        }

        return p;
      }); // This will make sure to move pseudo's to the correct spot (the end for
      // pseudo elements) because otherwise the selector will never work
      // anyway.
      //
      // E.g.:
      //  - `before:hover:text-center` would result in `.before\:hover\:text-center:hover::before`
      //  - `hover:before:text-center` would result in `.hover\:before\:text-center:hover::before`
      //
      // `::before:hover` doesn't work, which means that we can make it work for you by flipping the order.

      function collectPseudoElements(selector) {
        var nodes = [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = selector.nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var node = _step.value;

            if (isPseudoElement(node)) {
              nodes.push(node);
              selector.removeChild(node);
            }

            if (node === null || node === void 0 ? void 0 : node.nodes) {
              nodes.push.apply(nodes, _toConsumableArray(collectPseudoElements(node)));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return nodes;
      }

      var pseudoElements = collectPseudoElements(selector2);

      if (pseudoElements.length > 0) {
        selector2.nodes.push(pseudoElements.sort(sortSelector));
      }

      return selector2;
    });
  }).processSync(selector1);
} // Note: As a rule, double colons (::) should be used instead of a single colon
// (:). This distinguishes pseudo-classes from pseudo-elements. However, since
// this distinction was not present in older versions of the W3C spec, most
// browsers support both syntaxes for the original pseudo-elements.


var pseudoElementsBC = [':before', ':after', ':first-line', ':first-letter']; // These pseudo-elements _can_ be combined with other pseudo selectors AND the order does matter.

var pseudoElementExceptions = ['::file-selector-button']; // This will make sure to move pseudo's to the correct spot (the end for
// pseudo elements) because otherwise the selector will never work
// anyway.
//
// E.g.:
//  - `before:hover:text-center` would result in `.before\:hover\:text-center:hover::before`
//  - `hover:before:text-center` would result in `.hover\:before\:text-center:hover::before`
//
// `::before:hover` doesn't work, which means that we can make it work
// for you by flipping the order.

function sortSelector(a, z) {
  // Both nodes are non-pseudo's so we can safely ignore them and keep
  // them in the same order.
  if (a.type !== 'pseudo' && z.type !== 'pseudo') {
    return 0;
  } // If one of them is a combinator, we need to keep it in the same order
  // because that means it will start a new "section" in the selector.


  if (a.type === 'combinator' ^ z.type === 'combinator') {
    return 0;
  } // One of the items is a pseudo and the other one isn't. Let's move
  // the pseudo to the right.


  if (a.type === 'pseudo' ^ z.type === 'pseudo') {
    return (a.type === 'pseudo') - (z.type === 'pseudo');
  } // Both are pseudo's, move the pseudo elements (except for
  // ::file-selector-button) to the right.


  return isPseudoElement(a) - isPseudoElement(z);
}

function isPseudoElement(node) {
  if (node.type !== 'pseudo') return false;
  if (pseudoElementExceptions.includes(node.value)) return false;
  return node.value.startsWith('::') || pseudoElementsBC.includes(node.value);
}

function resolveFunctionArgument(haystack, needle, arg) {
  var startIdx = haystack.indexOf(arg ? "".concat(needle, "(").concat(arg, ")") : needle);
  if (startIdx === -1) return null; // Start inside the `(`

  startIdx += needle.length + 1;
  var target = '';
  var count = 0;
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = haystack.slice(startIdx)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _char = _step2.value;

      if (_char !== '(' && _char !== ')') {
        target += _char;
      } else if (_char === '(') {
        target += _char;
        count++;
      } else if (_char === ')') {
        if (--count < 0) break; // unbalanced

        target += _char;
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return target;
}