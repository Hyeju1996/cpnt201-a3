"use strict";

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = resolveConfig;

var _negateValue = _interopRequireDefault(require("./negateValue"));

var _corePluginList = _interopRequireDefault(require("../corePluginList"));

var _configurePlugins = _interopRequireDefault(require("./configurePlugins"));

var _defaultConfigStub = _interopRequireDefault(require("../../stubs/defaultConfig.stub"));

var _colors = _interopRequireDefault(require("../public/colors"));

var _defaults = require("./defaults");

var _toPath = require("./toPath");

var _normalizeConfig = require("./normalizeConfig");

var _isPlainObject = _interopRequireDefault(require("./isPlainObject"));

var _cloneDeep = require("./cloneDeep");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function isFunction(input) {
  return typeof input === 'function';
}

function isObject(input) {
  return _typeof(input) === 'object' && input !== null;
}

function mergeWith(target) {
  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }

  var customizer = sources.pop();

  for (var _i = 0, _sources = sources; _i < _sources.length; _i++) {
    var source = _sources[_i];

    for (var k in source) {
      var merged = customizer(target[k], source[k]);

      if (merged === undefined) {
        if (isObject(target[k]) && isObject(source[k])) {
          target[k] = mergeWith(target[k], source[k], customizer);
        } else {
          target[k] = source[k];
        }
      } else {
        target[k] = merged;
      }
    }
  }

  return target;
}

var configUtils = {
  colors: _colors["default"],
  negative: function negative(scale) {
    // TODO: Log that this function isn't really needed anymore?
    return Object.keys(scale).filter(function (key) {
      return scale[key] !== '0';
    }).reduce(function (negativeScale, key) {
      var negativeValue = (0, _negateValue)["default"](scale[key]);

      if (negativeValue !== undefined) {
        negativeScale["-".concat(key)] = negativeValue;
      }

      return negativeScale;
    }, {});
  },
  breakpoints: function breakpoints(screens) {
    return Object.keys(screens).filter(function (key) {
      return typeof screens[key] === 'string';
    }).reduce(function (breakpoints, key) {
      return _objectSpread({}, breakpoints, _defineProperty({}, "screen-".concat(key), screens[key]));
    }, {});
  }
};

function value(valueToResolve) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  return isFunction(valueToResolve) ? valueToResolve.apply(void 0, args) : valueToResolve;
}

function collectExtends(items) {
  return items.reduce(function (merged, _ref) {
    var extend = _ref.extend;
    return mergeWith(merged, extend, function (mergedValue, extendValue) {
      if (mergedValue === undefined) {
        return [extendValue];
      }

      if (Array.isArray(mergedValue)) {
        return [extendValue].concat(_toConsumableArray(mergedValue));
      }

      return [extendValue, mergedValue];
    });
  }, {});
}

function mergeThemes(themes) {
  return _objectSpread({}, themes.reduce(function (merged, theme) {
    return (0, _defaults).defaults(merged, theme);
  }, {}), {
    // In order to resolve n config objects, we combine all of their `extend` properties
    // into arrays instead of objects so they aren't overridden.
    extend: collectExtends(themes)
  });
}

function mergeExtensionCustomizer(merged, value1) {
  // When we have an array of objects, we do want to merge it
  if (Array.isArray(merged) && isObject(merged[0])) {
    return merged.concat(value1);
  } // When the incoming value is an array, and the existing config is an object, prepend the existing object


  if (Array.isArray(value1) && isObject(value1[0]) && isObject(merged)) {
    return [merged].concat(_toConsumableArray(value1));
  } // Override arrays (for example for font-families, box-shadows, ...)


  if (Array.isArray(value1)) {
    return value1;
  } // Execute default behaviour


  return undefined;
}

function mergeExtensions(_ref2) {
  var extend = _ref2.extend,
      theme = _objectWithoutProperties(_ref2, ["extend"]);

  return mergeWith(theme, extend, function (themeValue, extensions) {
    // The `extend` property is an array, so we need to check if it contains any functions
    if (!isFunction(themeValue) && !extensions.some(isFunction)) {
      return mergeWith.apply(void 0, [{}, themeValue].concat(_toConsumableArray(extensions), [mergeExtensionCustomizer]));
    }

    return function (resolveThemePath, utils) {
      return mergeWith.apply(void 0, [{}].concat(_toConsumableArray([themeValue].concat(_toConsumableArray(extensions)).map(function (e) {
        return value(e, resolveThemePath, utils);
      })), [mergeExtensionCustomizer]));
    };
  });
}

function resolveFunctionKeys(object) {
  var resolvePath = function resolvePath(key, defaultValue) {
    var path = (0, _toPath).toPath(key);
    var index = 0;
    var val = object;

    while (val !== undefined && val !== null && index < path.length) {
      val = val[path[index++]];
      val = isFunction(val) ? val(resolvePath, configUtils) : val;
    }

    if (val === undefined) {
      return defaultValue;
    }

    if ((0, _isPlainObject)["default"](val)) {
      return (0, _cloneDeep).cloneDeep(val);
    }

    return val;
  };

  resolvePath.theme = resolvePath;

  for (var key1 in configUtils) {
    resolvePath[key1] = configUtils[key1];
  }

  return Object.keys(object).reduce(function (resolved, key) {
    return _objectSpread({}, resolved, _defineProperty({}, key, isFunction(object[key]) ? object[key](resolvePath, configUtils) : object[key]));
  }, {});
}

function extractPluginConfigs(configs) {
  var allConfigs = [];
  configs.forEach(function (config) {
    allConfigs = [].concat(_toConsumableArray(allConfigs), [config]);
    var ref1;
    var plugins = (ref1 = config === null || config === void 0 ? void 0 : config.plugins) !== null && ref1 !== void 0 ? ref1 : [];

    if (plugins.length === 0) {
      return;
    }

    plugins.forEach(function (plugin) {
      if (plugin.__isOptionsFunction) {
        plugin = plugin();
      }

      var ref;
      allConfigs = [].concat(_toConsumableArray(allConfigs), _toConsumableArray(extractPluginConfigs([(ref = plugin === null || plugin === void 0 ? void 0 : plugin.config) !== null && ref !== void 0 ? ref : {}])));
    });
  });
  return allConfigs;
}

function resolveCorePlugins(corePluginConfigs) {
  var result = _toConsumableArray(corePluginConfigs).reduceRight(function (resolved, corePluginConfig) {
    if (isFunction(corePluginConfig)) {
      return corePluginConfig({
        corePlugins: resolved
      });
    }

    return (0, _configurePlugins)["default"](corePluginConfig, resolved);
  }, _corePluginList["default"]);

  return result;
}

function resolvePluginLists(pluginLists) {
  var result = _toConsumableArray(pluginLists).reduceRight(function (resolved, pluginList) {
    return [].concat(_toConsumableArray(resolved), _toConsumableArray(pluginList));
  }, []);

  return result;
}

function resolveConfig(configs) {
  var _ref3;

  var allConfigs = [].concat(_toConsumableArray(extractPluginConfigs(configs)), [{
    prefix: '',
    important: false,
    separator: ':',
    variantOrder: _defaultConfigStub["default"].variantOrder
  }]);
  var ref, ref2;
  return (0, _normalizeConfig).normalizeConfig((_ref3 = (0, _defaults)).defaults.apply(_ref3, [{
    theme: resolveFunctionKeys(mergeExtensions(mergeThemes(allConfigs.map(function (t) {
      return (ref = t === null || t === void 0 ? void 0 : t.theme) !== null && ref !== void 0 ? ref : {};
    })))),
    corePlugins: resolveCorePlugins(allConfigs.map(function (c) {
      return c.corePlugins;
    })),
    plugins: resolvePluginLists(configs.map(function (c) {
      return (ref2 = c === null || c === void 0 ? void 0 : c.plugins) !== null && ref2 !== void 0 ? ref2 : [];
    }))
  }].concat(_toConsumableArray(allConfigs))));
}