"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = setupTrackingContext;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _fastGlob = _interopRequireDefault(require("fast-glob"));

var _quickLru = _interopRequireDefault(require("quick-lru"));

var _normalizePath = _interopRequireDefault(require("normalize-path"));

var _hashConfig = _interopRequireDefault(require("../util/hashConfig"));

var _getModuleDependencies = _interopRequireDefault(require("../lib/getModuleDependencies"));

var _resolveConfig = _interopRequireDefault(require("../public/resolve-config"));

var _resolveConfigPath = _interopRequireDefault(require("../util/resolveConfigPath"));

var _sharedState = require("./sharedState");

var _setupContextUtils = require("./setupContextUtils");

var _parseDependency = _interopRequireDefault(require("../util/parseDependency"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var configPathCache = new _quickLru["default"]({
  maxSize: 100
});
var candidateFilesCache = new WeakMap();

function getCandidateFiles(context, tailwindConfig) {
  if (candidateFilesCache.has(context)) {
    return candidateFilesCache.get(context);
  }

  var candidateFiles = tailwindConfig.content.files.filter(function (item) {
    return typeof item === 'string';
  }).map(function (contentPath) {
    return (0, _normalizePath["default"])(contentPath);
  });
  return candidateFilesCache.set(context, candidateFiles).get(context);
} // Get the config object based on a path


function getTailwindConfig(configOrPath) {
  var userConfigPath = (0, _resolveConfigPath["default"])(configOrPath);

  if (userConfigPath !== null) {
    var _ref = configPathCache.get(userConfigPath) || [],
        _ref2 = _slicedToArray(_ref, 4),
        prevConfig = _ref2[0],
        prevConfigHash = _ref2[1],
        prevDeps = _ref2[2],
        prevModified = _ref2[3];

    var newDeps = (0, _getModuleDependencies["default"])(userConfigPath).map(function (dep) {
      return dep.file;
    });
    var modified = false;
    var newModified = new Map();
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = newDeps[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var file = _step.value;

        var time = _fs["default"].statSync(file).mtimeMs;

        newModified.set(file, time);

        if (!prevModified || !prevModified.has(file) || time > prevModified.get(file)) {
          modified = true;
        }
      } // It hasn't changed (based on timestamps)

    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (!modified) {
      return [prevConfig, userConfigPath, prevConfigHash, prevDeps];
    } // It has changed (based on timestamps), or first run


    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = newDeps[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var _file = _step2.value;
        delete require.cache[_file];
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    var _newConfig = (0, _resolveConfig["default"])(require(userConfigPath));

    var newHash = (0, _hashConfig["default"])(_newConfig);
    configPathCache.set(userConfigPath, [_newConfig, newHash, newDeps, newModified]);
    return [_newConfig, userConfigPath, newHash, newDeps];
  } // It's a plain object, not a path


  var newConfig = (0, _resolveConfig["default"])(configOrPath.config === undefined ? configOrPath : configOrPath.config);
  return [newConfig, null, (0, _hashConfig["default"])(newConfig), []];
}

function resolvedChangedContent(context, candidateFiles, fileModifiedMap) {
  var changedContent = context.tailwindConfig.content.files.filter(function (item) {
    return typeof item.raw === 'string';
  }).map(function (_ref3) {
    var raw = _ref3.raw,
        _ref3$extension = _ref3.extension,
        extension = _ref3$extension === void 0 ? 'html' : _ref3$extension;
    return {
      content: raw,
      extension: extension
    };
  });
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = resolveChangedFiles(candidateFiles, fileModifiedMap)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var changedFile = _step3.value;

      var content = _fs["default"].readFileSync(changedFile, 'utf8');

      var extension = _path["default"].extname(changedFile).slice(1);

      changedContent.push({
        content: content,
        extension: extension
      });
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return changedContent;
}

function resolveChangedFiles(candidateFiles, fileModifiedMap) {
  var changedFiles = new Set();
  _sharedState.env.DEBUG && console.time('Finding changed files');

  var files = _fastGlob["default"].sync(candidateFiles);

  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = files[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var file = _step4.value;
      var prevModified = fileModifiedMap.has(file) ? fileModifiedMap.get(file) : -Infinity;

      var modified = _fs["default"].statSync(file).mtimeMs;

      if (modified > prevModified) {
        changedFiles.add(file);
        fileModifiedMap.set(file, modified);
      }
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
        _iterator4["return"]();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  _sharedState.env.DEBUG && console.timeEnd('Finding changed files');
  return changedFiles;
} // DISABLE_TOUCH = TRUE
// Retrieve an existing context from cache if possible (since contexts are unique per
// source path), or set up a new one (including setting up watchers and registering
// plugins) then return it


function setupTrackingContext(configOrPath) {
  return function (_ref4) {
    var tailwindDirectives = _ref4.tailwindDirectives,
        registerDependency = _ref4.registerDependency,
        applyDirectives = _ref4.applyDirectives;
    return function (root, result) {
      var _getTailwindConfig = getTailwindConfig(configOrPath),
          _getTailwindConfig2 = _slicedToArray(_getTailwindConfig, 4),
          tailwindConfig = _getTailwindConfig2[0],
          userConfigPath = _getTailwindConfig2[1],
          tailwindConfigHash = _getTailwindConfig2[2],
          configDependencies = _getTailwindConfig2[3];

      var contextDependencies = new Set(configDependencies); // If there are no @tailwind or @apply rules, we don't consider this CSS
      // file or its dependencies to be dependencies of the context. Can reuse
      // the context even if they change. We may want to think about `@layer`
      // being part of this trigger too, but it's tough because it's impossible
      // for a layer in one file to end up in the actual @tailwind rule in
      // another file since independent sources are effectively isolated.

      if (tailwindDirectives.size > 0 || applyDirectives.size > 0) {
        // Add current css file as a context dependencies.
        contextDependencies.add(result.opts.from); // Add all css @import dependencies as context dependencies.

        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = result.messages[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var message = _step5.value;

            if (message.type === 'dependency') {
              contextDependencies.add(message.file);
            }
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
              _iterator5["return"]();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }
      }

      var _getContext = (0, _setupContextUtils.getContext)(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies),
          _getContext2 = _slicedToArray(_getContext, 1),
          context = _getContext2[0];

      var candidateFiles = getCandidateFiles(context, tailwindConfig); // If there are no @tailwind or @apply rules, we don't consider this CSS file or it's
      // dependencies to be dependencies of the context. Can reuse the context even if they change.
      // We may want to think about `@layer` being part of this trigger too, but it's tough
      // because it's impossible for a layer in one file to end up in the actual @tailwind rule
      // in another file since independent sources are effectively isolated.

      if (tailwindDirectives.size > 0 || applyDirectives.size > 0) {
        var fileModifiedMap = (0, _setupContextUtils.getFileModifiedMap)(context); // Add template paths as postcss dependencies.

        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
          for (var _iterator6 = candidateFiles[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var fileOrGlob = _step6.value;
            var dependency = (0, _parseDependency["default"])(fileOrGlob);

            if (dependency) {
              registerDependency(dependency);
            }
          }
        } catch (err) {
          _didIteratorError6 = true;
          _iteratorError6 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
              _iterator6["return"]();
            }
          } finally {
            if (_didIteratorError6) {
              throw _iteratorError6;
            }
          }
        }

        var _iteratorNormalCompletion7 = true;
        var _didIteratorError7 = false;
        var _iteratorError7 = undefined;

        try {
          for (var _iterator7 = resolvedChangedContent(context, candidateFiles, fileModifiedMap)[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
            var changedContent = _step7.value;
            context.changedContent.push(changedContent);
          }
        } catch (err) {
          _didIteratorError7 = true;
          _iteratorError7 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
              _iterator7["return"]();
            }
          } finally {
            if (_didIteratorError7) {
              throw _iteratorError7;
            }
          }
        }
      }

      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = configDependencies[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var file = _step8.value;
          registerDependency({
            type: 'dependency',
            file: file
          });
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
            _iterator8["return"]();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }

      return context;
    };
  };
}