"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var parser = require('postcss-value-parser');

var range = require('normalize-range');

var OldValue = require('../old-value');

var Value = require('../value');

var utils = require('../utils');

var IS_DIRECTION = /top|left|right|bottom/gi;

var Gradient =
/*#__PURE__*/
function (_Value) {
  _inherits(Gradient, _Value);

  function Gradient() {
    _classCallCheck(this, Gradient);

    return _possibleConstructorReturn(this, _getPrototypeOf(Gradient).apply(this, arguments));
  }

  _createClass(Gradient, [{
    key: "replace",

    /**
     * Change degrees for webkit prefix
     */
    value: function replace(string, prefix) {
      var ast = parser(string);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = ast.nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var node = _step.value;

          if (node.type === 'function' && node.value === this.name) {
            node.nodes = this.newDirection(node.nodes);
            node.nodes = this.normalize(node.nodes);

            if (prefix === '-webkit- old') {
              var changes = this.oldWebkit(node);

              if (!changes) {
                return false;
              }
            } else {
              node.nodes = this.convertDirection(node.nodes);
              node.value = prefix + node.value;
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return ast.toString();
    }
    /**
     * Replace first token
     */

  }, {
    key: "replaceFirst",
    value: function replaceFirst(params) {
      for (var _len = arguments.length, words = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        words[_key - 1] = arguments[_key];
      }

      var prefix = words.map(function (i) {
        if (i === ' ') {
          return {
            type: 'space',
            value: i
          };
        }

        return {
          type: 'word',
          value: i
        };
      });
      return prefix.concat(params.slice(1));
    }
    /**
     * Convert angle unit to deg
     */

  }, {
    key: "normalizeUnit",
    value: function normalizeUnit(str, full) {
      var num = parseFloat(str);
      var deg = num / full * 360;
      return "".concat(deg, "deg");
    }
    /**
     * Normalize angle
     */

  }, {
    key: "normalize",
    value: function normalize(nodes) {
      if (!nodes[0]) return nodes;

      if (/-?\d+(.\d+)?grad/.test(nodes[0].value)) {
        nodes[0].value = this.normalizeUnit(nodes[0].value, 400);
      } else if (/-?\d+(.\d+)?rad/.test(nodes[0].value)) {
        nodes[0].value = this.normalizeUnit(nodes[0].value, 2 * Math.PI);
      } else if (/-?\d+(.\d+)?turn/.test(nodes[0].value)) {
        nodes[0].value = this.normalizeUnit(nodes[0].value, 1);
      } else if (nodes[0].value.includes('deg')) {
        var num = parseFloat(nodes[0].value);
        num = range.wrap(0, 360, num);
        nodes[0].value = "".concat(num, "deg");
      }

      if (nodes[0].value === '0deg') {
        nodes = this.replaceFirst(nodes, 'to', ' ', 'top');
      } else if (nodes[0].value === '90deg') {
        nodes = this.replaceFirst(nodes, 'to', ' ', 'right');
      } else if (nodes[0].value === '180deg') {
        nodes = this.replaceFirst(nodes, 'to', ' ', 'bottom');
      } else if (nodes[0].value === '270deg') {
        nodes = this.replaceFirst(nodes, 'to', ' ', 'left');
      }

      return nodes;
    }
    /**
     * Replace old direction to new
     */

  }, {
    key: "newDirection",
    value: function newDirection(params) {
      if (params[0].value === 'to') {
        return params;
      }

      IS_DIRECTION.lastIndex = 0; // reset search index of global regexp

      if (!IS_DIRECTION.test(params[0].value)) {
        return params;
      }

      params.unshift({
        type: 'word',
        value: 'to'
      }, {
        type: 'space',
        value: ' '
      });

      for (var i = 2; i < params.length; i++) {
        if (params[i].type === 'div') {
          break;
        }

        if (params[i].type === 'word') {
          params[i].value = this.revertDirection(params[i].value);
        }
      }

      return params;
    }
    /**
     * Look for at word
     */

  }, {
    key: "isRadial",
    value: function isRadial(params) {
      var state = 'before';
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = params[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var param = _step2.value;

          if (state === 'before' && param.type === 'space') {
            state = 'at';
          } else if (state === 'at' && param.value === 'at') {
            state = 'after';
          } else if (state === 'after' && param.type === 'space') {
            return true;
          } else if (param.type === 'div') {
            break;
          } else {
            state = 'before';
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return false;
    }
    /**
     * Change new direction to old
     */

  }, {
    key: "convertDirection",
    value: function convertDirection(params) {
      if (params.length > 0) {
        if (params[0].value === 'to') {
          this.fixDirection(params);
        } else if (params[0].value.includes('deg')) {
          this.fixAngle(params);
        } else if (this.isRadial(params)) {
          this.fixRadial(params);
        }
      }

      return params;
    }
    /**
     * Replace `to top left` to `bottom right`
     */

  }, {
    key: "fixDirection",
    value: function fixDirection(params) {
      params.splice(0, 2);
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = params[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var param = _step3.value;

          if (param.type === 'div') {
            break;
          }

          if (param.type === 'word') {
            param.value = this.revertDirection(param.value);
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
    /**
     * Add 90 degrees
     */

  }, {
    key: "fixAngle",
    value: function fixAngle(params) {
      var first = params[0].value;
      first = parseFloat(first);
      first = Math.abs(450 - first) % 360;
      first = this.roundFloat(first, 3);
      params[0].value = "".concat(first, "deg");
    }
    /**
     * Fix radial direction syntax
     */

  }, {
    key: "fixRadial",
    value: function fixRadial(params) {
      var first = [];
      var second = [];
      var a, b, c, i, next;

      for (i = 0; i < params.length - 2; i++) {
        a = params[i];
        b = params[i + 1];
        c = params[i + 2];

        if (a.type === 'space' && b.value === 'at' && c.type === 'space') {
          next = i + 3;
          break;
        } else {
          first.push(a);
        }
      }

      var div;

      for (i = next; i < params.length; i++) {
        if (params[i].type === 'div') {
          div = params[i];
          break;
        } else {
          second.push(params[i]);
        }
      }

      params.splice.apply(params, [0, i].concat(second, [div], first));
    }
  }, {
    key: "revertDirection",
    value: function revertDirection(word) {
      return Gradient.directions[word.toLowerCase()] || word;
    }
    /**
     * Round float and save digits under dot
     */

  }, {
    key: "roundFloat",
    value: function roundFloat(_float, digits) {
      return parseFloat(_float.toFixed(digits));
    }
    /**
     * Convert to old webkit syntax
     */

  }, {
    key: "oldWebkit",
    value: function oldWebkit(node) {
      var nodes = node.nodes;
      var string = parser.stringify(node.nodes);

      if (this.name !== 'linear-gradient') {
        return false;
      }

      if (nodes[0] && nodes[0].value.includes('deg')) {
        return false;
      }

      if (string.includes('px') || string.includes('-corner') || string.includes('-side')) {
        return false;
      }

      var params = [[]];
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = nodes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var i = _step4.value;
          params[params.length - 1].push(i);

          if (i.type === 'div' && i.value === ',') {
            params.push([]);
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      this.oldDirection(params);
      this.colorStops(params);
      node.nodes = [];

      for (var _i = 0, _params = params; _i < _params.length; _i++) {
        var param = _params[_i];
        node.nodes = node.nodes.concat(param);
      }

      node.nodes.unshift({
        type: 'word',
        value: 'linear'
      }, this.cloneDiv(node.nodes));
      node.value = '-webkit-gradient';
      return true;
    }
    /**
     * Change direction syntax to old webkit
     */

  }, {
    key: "oldDirection",
    value: function oldDirection(params) {
      var div = this.cloneDiv(params[0]);

      if (params[0][0].value !== 'to') {
        return params.unshift([{
          type: 'word',
          value: Gradient.oldDirections.bottom
        }, div]);
      } else {
        var words = [];
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = params[0].slice(2)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var node = _step5.value;

            if (node.type === 'word') {
              words.push(node.value.toLowerCase());
            }
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
              _iterator5["return"]();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }

        words = words.join(' ');
        var old = Gradient.oldDirections[words] || words;
        params[0] = [{
          type: 'word',
          value: old
        }, div];
        return params[0];
      }
    }
    /**
     * Get div token from exists parameters
     */

  }, {
    key: "cloneDiv",
    value: function cloneDiv(params) {
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = params[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var i = _step6.value;

          if (i.type === 'div' && i.value === ',') {
            return i;
          }
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
            _iterator6["return"]();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      return {
        type: 'div',
        value: ',',
        after: ' '
      };
    }
    /**
     * Change colors syntax to old webkit
     */

  }, {
    key: "colorStops",
    value: function colorStops(params) {
      var result = [];

      for (var i = 0; i < params.length; i++) {
        var pos = void 0;
        var param = params[i];
        var item = void 0;

        if (i === 0) {
          continue;
        }

        var color = parser.stringify(param[0]);

        if (param[1] && param[1].type === 'word') {
          pos = param[1].value;
        } else if (param[2] && param[2].type === 'word') {
          pos = param[2].value;
        }

        var stop = void 0;

        if (i === 1 && (!pos || pos === '0%')) {
          stop = "from(".concat(color, ")");
        } else if (i === params.length - 1 && (!pos || pos === '100%')) {
          stop = "to(".concat(color, ")");
        } else if (pos) {
          stop = "color-stop(".concat(pos, ", ").concat(color, ")");
        } else {
          stop = "color-stop(".concat(color, ")");
        }

        var div = param[param.length - 1];
        params[i] = [{
          type: 'word',
          value: stop
        }];

        if (div.type === 'div' && div.value === ',') {
          item = params[i].push(div);
        }

        result.push(item);
      }

      return result;
    }
    /**
     * Remove old WebKit gradient too
     */

  }, {
    key: "old",
    value: function old(prefix) {
      if (prefix === '-webkit-') {
        var type = this.name === 'linear-gradient' ? 'linear' : 'radial';
        var string = '-gradient';
        var regexp = utils.regexp("-webkit-(".concat(type, "-gradient|gradient\\(\\s*").concat(type, ")"), false);
        return new OldValue(this.name, prefix + this.name, string, regexp);
      } else {
        return _get(_getPrototypeOf(Gradient.prototype), "old", this).call(this, prefix);
      }
    }
    /**
     * Do not add non-webkit prefixes for list-style and object
     */

  }, {
    key: "add",
    value: function add(decl, prefix) {
      var p = decl.prop;

      if (p.includes('mask')) {
        if (prefix === '-webkit-' || prefix === '-webkit- old') {
          return _get(_getPrototypeOf(Gradient.prototype), "add", this).call(this, decl, prefix);
        }
      } else if (p === 'list-style' || p === 'list-style-image' || p === 'content') {
        if (prefix === '-webkit-' || prefix === '-webkit- old') {
          return _get(_getPrototypeOf(Gradient.prototype), "add", this).call(this, decl, prefix);
        }
      } else {
        return _get(_getPrototypeOf(Gradient.prototype), "add", this).call(this, decl, prefix);
      }

      return undefined;
    }
  }]);

  return Gradient;
}(Value);

Gradient.names = ['linear-gradient', 'repeating-linear-gradient', 'radial-gradient', 'repeating-radial-gradient'];
Gradient.directions = {
  top: 'bottom',
  left: 'right',
  bottom: 'top',
  right: 'left'
}; // Direction to replace

Gradient.oldDirections = {
  'top': 'left bottom, left top',
  'left': 'right top, left top',
  'bottom': 'left top, left bottom',
  'right': 'left top, right top',
  'top right': 'left bottom, right top',
  'top left': 'right bottom, left top',
  'right top': 'left bottom, right top',
  'right bottom': 'left top, right bottom',
  'bottom right': 'left top, right bottom',
  'bottom left': 'right top, left bottom',
  'left top': 'right bottom, left top',
  'left bottom': 'right top, left bottom'
};
module.exports = Gradient;