"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var featureQueries = require('caniuse-lite/data/features/css-featurequeries.js');

var _require = require('caniuse-lite'),
    feature = _require.feature;

var _require2 = require('postcss'),
    parse = _require2.parse;

var Browsers = require('./browsers');

var brackets = require('./brackets');

var Value = require('./value');

var utils = require('./utils');

var data = feature(featureQueries);
var supported = [];

for (var browser in data.stats) {
  var versions = data.stats[browser];

  for (var version in versions) {
    var support = versions[version];

    if (/y/.test(support)) {
      supported.push(browser + ' ' + version);
    }
  }
}

var Supports =
/*#__PURE__*/
function () {
  function Supports(Prefixes, all) {
    _classCallCheck(this, Supports);

    this.Prefixes = Prefixes;
    this.all = all;
  }
  /**
   * Return prefixer only with @supports supported browsers
   */


  _createClass(Supports, [{
    key: "prefixer",
    value: function prefixer() {
      if (this.prefixerCache) {
        return this.prefixerCache;
      }

      var filtered = this.all.browsers.selected.filter(function (i) {
        return supported.includes(i);
      });
      var browsers = new Browsers(this.all.browsers.data, filtered, this.all.options);
      this.prefixerCache = new this.Prefixes(this.all.data, browsers, this.all.options);
      return this.prefixerCache;
    }
    /**
     * Parse string into declaration property and value
     */

  }, {
    key: "parse",
    value: function parse(str) {
      var parts = str.split(':');
      var prop = parts[0];
      var value = parts[1];
      if (!value) value = '';
      return [prop.trim(), value.trim()];
    }
    /**
     * Create virtual rule to process it by prefixer
     */

  }, {
    key: "virtual",
    value: function virtual(str) {
      var _this$parse = this.parse(str),
          _this$parse2 = _slicedToArray(_this$parse, 2),
          prop = _this$parse2[0],
          value = _this$parse2[1];

      var rule = parse('a{}').first;
      rule.append({
        prop: prop,
        value: value,
        raws: {
          before: ''
        }
      });
      return rule;
    }
    /**
     * Return array of Declaration with all necessary prefixes
     */

  }, {
    key: "prefixed",
    value: function prefixed(str) {
      var rule = this.virtual(str);

      if (this.disabled(rule.first)) {
        return rule.nodes;
      }

      var result = {
        warn: function warn() {
          return null;
        }
      };
      var prefixer = this.prefixer().add[rule.first.prop];
      prefixer && prefixer.process && prefixer.process(rule.first, result);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = rule.nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var decl = _step.value;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = this.prefixer().values('add', rule.first.prop)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var value = _step2.value;
              value.process(decl);
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          Value.save(this.all, decl);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return rule.nodes;
    }
    /**
     * Return true if brackets node is "not" word
     */

  }, {
    key: "isNot",
    value: function isNot(node) {
      return typeof node === 'string' && /not\s*/i.test(node);
    }
    /**
     * Return true if brackets node is "or" word
     */

  }, {
    key: "isOr",
    value: function isOr(node) {
      return typeof node === 'string' && /\s*or\s*/i.test(node);
    }
    /**
     * Return true if brackets node is (prop: value)
     */

  }, {
    key: "isProp",
    value: function isProp(node) {
      return _typeof(node) === 'object' && node.length === 1 && typeof node[0] === 'string';
    }
    /**
     * Return true if prefixed property has no unprefixed
     */

  }, {
    key: "isHack",
    value: function isHack(all, unprefixed) {
      var check = new RegExp("(\\(|\\s)".concat(utils.escapeRegexp(unprefixed), ":"));
      return !check.test(all);
    }
    /**
     * Return true if we need to remove node
     */

  }, {
    key: "toRemove",
    value: function toRemove(str, all) {
      var _this$parse3 = this.parse(str),
          _this$parse4 = _slicedToArray(_this$parse3, 2),
          prop = _this$parse4[0],
          value = _this$parse4[1];

      var unprefixed = this.all.unprefixed(prop);
      var cleaner = this.all.cleaner();

      if (cleaner.remove[prop] && cleaner.remove[prop].remove && !this.isHack(all, unprefixed)) {
        return true;
      }

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = cleaner.values('remove', unprefixed)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var checker = _step3.value;

          if (checker.check(value)) {
            return true;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return false;
    }
    /**
     * Remove all unnecessary prefixes
     */

  }, {
    key: "remove",
    value: function remove(nodes, all) {
      var i = 0;

      while (i < nodes.length) {
        if (!this.isNot(nodes[i - 1]) && this.isProp(nodes[i]) && this.isOr(nodes[i + 1])) {
          if (this.toRemove(nodes[i][0], all)) {
            nodes.splice(i, 2);
            continue;
          }

          i += 2;
          continue;
        }

        if (_typeof(nodes[i]) === 'object') {
          nodes[i] = this.remove(nodes[i], all);
        }

        i += 1;
      }

      return nodes;
    }
    /**
     * Clean brackets with one child
     */

  }, {
    key: "cleanBrackets",
    value: function cleanBrackets(nodes) {
      var _this = this;

      return nodes.map(function (i) {
        if (_typeof(i) !== 'object') {
          return i;
        }

        if (i.length === 1 && _typeof(i[0]) === 'object') {
          return _this.cleanBrackets(i[0]);
        }

        return _this.cleanBrackets(i);
      });
    }
    /**
     * Add " or " between properties and convert it to brackets format
     */

  }, {
    key: "convert",
    value: function convert(progress) {
      var result = [''];
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = progress[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var i = _step4.value;
          result.push(["".concat(i.prop, ": ").concat(i.value)]);
          result.push(' or ');
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      result[result.length - 1] = '';
      return result;
    }
    /**
     * Compress value functions into a string nodes
     */

  }, {
    key: "normalize",
    value: function normalize(nodes) {
      var _this2 = this;

      if (_typeof(nodes) !== 'object') {
        return nodes;
      }

      nodes = nodes.filter(function (i) {
        return i !== '';
      });

      if (typeof nodes[0] === 'string') {
        var firstNode = nodes[0].trim();

        if (firstNode.includes(':') || firstNode === 'selector' || firstNode === 'not selector') {
          return [brackets.stringify(nodes)];
        }
      }

      return nodes.map(function (i) {
        return _this2.normalize(i);
      });
    }
    /**
     * Add prefixes
     */

  }, {
    key: "add",
    value: function add(nodes, all) {
      var _this3 = this;

      return nodes.map(function (i) {
        if (_this3.isProp(i)) {
          var prefixed = _this3.prefixed(i[0]);

          if (prefixed.length > 1) {
            return _this3.convert(prefixed);
          }

          return i;
        }

        if (_typeof(i) === 'object') {
          return _this3.add(i, all);
        }

        return i;
      });
    }
    /**
     * Add prefixed declaration
     */

  }, {
    key: "process",
    value: function process(rule) {
      var ast = brackets.parse(rule.params);
      ast = this.normalize(ast);
      ast = this.remove(ast, rule.params);
      ast = this.add(ast, rule.params);
      ast = this.cleanBrackets(ast);
      rule.params = brackets.stringify(ast);
    }
    /**
     * Check global options
     */

  }, {
    key: "disabled",
    value: function disabled(node) {
      if (!this.all.options.grid) {
        if (node.prop === 'display' && node.value.includes('grid')) {
          return true;
        }

        if (node.prop.includes('grid') || node.prop === 'justify-items') {
          return true;
        }
      }

      if (this.all.options.flexbox === false) {
        if (node.prop === 'display' && node.value.includes('flex')) {
          return true;
        }

        var other = ['order', 'justify-content', 'align-items', 'align-content'];

        if (node.prop.includes('flex') || other.includes(node.prop)) {
          return true;
        }
      }

      return false;
    }
  }]);

  return Supports;
}();

module.exports = Supports;