"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var parser = require('postcss-value-parser');

var Value = require('./value');

var insertAreas = require('./hacks/grid-utils').insertAreas;

var OLD_LINEAR = /(^|[^-])linear-gradient\(\s*(top|left|right|bottom)/i;
var OLD_RADIAL = /(^|[^-])radial-gradient\(\s*\d+(\w*|%)\s+\d+(\w*|%)\s*,/i;
var IGNORE_NEXT = /(!\s*)?autoprefixer:\s*ignore\s+next/i;
var GRID_REGEX = /(!\s*)?autoprefixer\s*grid:\s*(on|off|(no-)?autoplace)/i;
var SIZES = ['width', 'height', 'min-width', 'max-width', 'min-height', 'max-height', 'inline-size', 'min-inline-size', 'max-inline-size', 'block-size', 'min-block-size', 'max-block-size'];

function hasGridTemplate(decl) {
  return decl.parent.some(function (i) {
    return i.prop === 'grid-template' || i.prop === 'grid-template-areas';
  });
}

function hasRowsAndColumns(decl) {
  var hasRows = decl.parent.some(function (i) {
    return i.prop === 'grid-template-rows';
  });
  var hasColumns = decl.parent.some(function (i) {
    return i.prop === 'grid-template-columns';
  });
  return hasRows && hasColumns;
}

var Processor =
/*#__PURE__*/
function () {
  function Processor(prefixes) {
    _classCallCheck(this, Processor);

    this.prefixes = prefixes;
  }
  /**
   * Add necessary prefixes
   */


  _createClass(Processor, [{
    key: "add",
    value: function add(css, result) {
      var _this = this;

      // At-rules
      var resolution = this.prefixes.add['@resolution'];
      var keyframes = this.prefixes.add['@keyframes'];
      var viewport = this.prefixes.add['@viewport'];
      var supports = this.prefixes.add['@supports'];
      css.walkAtRules(function (rule) {
        if (rule.name === 'keyframes') {
          if (!_this.disabled(rule, result)) {
            return keyframes && keyframes.process(rule);
          }
        } else if (rule.name === 'viewport') {
          if (!_this.disabled(rule, result)) {
            return viewport && viewport.process(rule);
          }
        } else if (rule.name === 'supports') {
          if (_this.prefixes.options.supports !== false && !_this.disabled(rule, result)) {
            return supports.process(rule);
          }
        } else if (rule.name === 'media' && rule.params.includes('-resolution')) {
          if (!_this.disabled(rule, result)) {
            return resolution && resolution.process(rule);
          }
        }

        return undefined;
      }); // Selectors

      css.walkRules(function (rule) {
        if (_this.disabled(rule, result)) return undefined;
        return _this.prefixes.add.selectors.map(function (selector) {
          return selector.process(rule, result);
        });
      });

      function insideGrid(decl) {
        return decl.parent.nodes.some(function (node) {
          if (node.type !== 'decl') return false;
          var displayGrid = node.prop === 'display' && /(inline-)?grid/.test(node.value);
          var gridTemplate = node.prop.startsWith('grid-template');
          var gridGap = /^grid-([A-z]+-)?gap/.test(node.prop);
          return displayGrid || gridTemplate || gridGap;
        });
      }

      function insideFlex(decl) {
        return decl.parent.some(function (node) {
          return node.prop === 'display' && /(inline-)?flex/.test(node.value);
        });
      }

      var gridPrefixes = this.gridStatus(css, result) && this.prefixes.add['grid-area'] && this.prefixes.add['grid-area'].prefixes;
      css.walkDecls(function (decl) {
        if (_this.disabledDecl(decl, result)) return undefined;
        var parent = decl.parent;
        var prop = decl.prop;
        var value = decl.value;

        if (prop === 'grid-row-span') {
          result.warn('grid-row-span is not part of final Grid Layout. Use grid-row.', {
            node: decl
          });
          return undefined;
        } else if (prop === 'grid-column-span') {
          result.warn('grid-column-span is not part of final Grid Layout. Use grid-column.', {
            node: decl
          });
          return undefined;
        } else if (prop === 'display' && value === 'box') {
          result.warn('You should write display: flex by final spec ' + 'instead of display: box', {
            node: decl
          });
          return undefined;
        } else if (prop === 'text-emphasis-position') {
          if (value === 'under' || value === 'over') {
            result.warn('You should use 2 values for text-emphasis-position ' + 'For example, `under left` instead of just `under`.', {
              node: decl
            });
          }
        } else if (/^(align|justify|place)-(items|content)$/.test(prop) && insideFlex(decl)) {
          if (value === 'start' || value === 'end') {
            result.warn("".concat(value, " value has mixed support, consider using ") + "flex-".concat(value, " instead"), {
              node: decl
            });
          }
        } else if (prop === 'text-decoration-skip' && value === 'ink') {
          result.warn('Replace text-decoration-skip: ink to ' + 'text-decoration-skip-ink: auto, because spec had been changed', {
            node: decl
          });
        } else {
          if (gridPrefixes && _this.gridStatus(decl, result)) {
            if (decl.value === 'subgrid') {
              result.warn('IE does not support subgrid', {
                node: decl
              });
            }

            if (/^(align|justify|place)-items$/.test(prop) && insideGrid(decl)) {
              var fixed = prop.replace('-items', '-self');
              result.warn("IE does not support ".concat(prop, " on grid containers. ") + "Try using ".concat(fixed, " on child elements instead: ") + "".concat(decl.parent.selector, " > * { ").concat(fixed, ": ").concat(decl.value, " }"), {
                node: decl
              });
            } else if (/^(align|justify|place)-content$/.test(prop) && insideGrid(decl)) {
              result.warn("IE does not support ".concat(decl.prop, " on grid containers"), {
                node: decl
              });
            } else if (prop === 'display' && decl.value === 'contents') {
              result.warn('Please do not use display: contents; ' + 'if you have grid setting enabled', {
                node: decl
              });
              return undefined;
            } else if (decl.prop === 'grid-gap') {
              var status = _this.gridStatus(decl, result);

              if (status === 'autoplace' && !hasRowsAndColumns(decl) && !hasGridTemplate(decl)) {
                result.warn('grid-gap only works if grid-template(-areas) is being ' + 'used or both rows and columns have been declared ' + 'and cells have not been manually ' + 'placed inside the explicit grid', {
                  node: decl
                });
              } else if ((status === true || status === 'no-autoplace') && !hasGridTemplate(decl)) {
                result.warn('grid-gap only works if grid-template(-areas) is being used', {
                  node: decl
                });
              }
            } else if (prop === 'grid-auto-columns') {
              result.warn('grid-auto-columns is not supported by IE', {
                node: decl
              });
              return undefined;
            } else if (prop === 'grid-auto-rows') {
              result.warn('grid-auto-rows is not supported by IE', {
                node: decl
              });
              return undefined;
            } else if (prop === 'grid-auto-flow') {
              var hasRows = parent.some(function (i) {
                return i.prop === 'grid-template-rows';
              });
              var hasCols = parent.some(function (i) {
                return i.prop === 'grid-template-columns';
              });

              if (hasGridTemplate(decl)) {
                result.warn('grid-auto-flow is not supported by IE', {
                  node: decl
                });
              } else if (value.includes('dense')) {
                result.warn('grid-auto-flow: dense is not supported by IE', {
                  node: decl
                });
              } else if (!hasRows && !hasCols) {
                result.warn('grid-auto-flow works only if grid-template-rows and ' + 'grid-template-columns are present in the same rule', {
                  node: decl
                });
              }

              return undefined;
            } else if (value.includes('auto-fit')) {
              result.warn('auto-fit value is not supported by IE', {
                node: decl,
                word: 'auto-fit'
              });
              return undefined;
            } else if (value.includes('auto-fill')) {
              result.warn('auto-fill value is not supported by IE', {
                node: decl,
                word: 'auto-fill'
              });
              return undefined;
            } else if (prop.startsWith('grid-template') && value.includes('[')) {
              result.warn('Autoprefixer currently does not support line names. ' + 'Try using grid-template-areas instead.', {
                node: decl,
                word: '['
              });
            }
          }

          if (value.includes('radial-gradient')) {
            if (OLD_RADIAL.test(decl.value)) {
              result.warn('Gradient has outdated direction syntax. ' + 'New syntax is like `closest-side at 0 0` ' + 'instead of `0 0, closest-side`.', {
                node: decl
              });
            } else {
              var ast = parser(value);
              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = undefined;

              try {
                for (var _iterator = ast.nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var i = _step.value;

                  if (i.type === 'function' && i.value === 'radial-gradient') {
                    var _iteratorNormalCompletion2 = true;
                    var _didIteratorError2 = false;
                    var _iteratorError2 = undefined;

                    try {
                      for (var _iterator2 = i.nodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var word = _step2.value;

                        if (word.type === 'word') {
                          if (word.value === 'cover') {
                            result.warn('Gradient has outdated direction syntax. ' + 'Replace `cover` to `farthest-corner`.', {
                              node: decl
                            });
                          } else if (word.value === 'contain') {
                            result.warn('Gradient has outdated direction syntax. ' + 'Replace `contain` to `closest-side`.', {
                              node: decl
                            });
                          }
                        }
                      }
                    } catch (err) {
                      _didIteratorError2 = true;
                      _iteratorError2 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                          _iterator2["return"]();
                        }
                      } finally {
                        if (_didIteratorError2) {
                          throw _iteratorError2;
                        }
                      }
                    }
                  }
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                    _iterator["return"]();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }
            }
          }

          if (value.includes('linear-gradient')) {
            if (OLD_LINEAR.test(value)) {
              result.warn('Gradient has outdated direction syntax. ' + 'New syntax is like `to left` instead of `right`.', {
                node: decl
              });
            }
          }
        }

        if (SIZES.includes(decl.prop)) {
          if (!decl.value.includes('-fill-available')) {
            if (decl.value.includes('fill-available')) {
              result.warn('Replace fill-available to stretch, ' + 'because spec had been changed', {
                node: decl
              });
            } else if (decl.value.includes('fill')) {
              var _ast = parser(value);

              if (_ast.nodes.some(function (i) {
                return i.type === 'word' && i.value === 'fill';
              })) {
                result.warn('Replace fill to stretch, because spec had been changed', {
                  node: decl
                });
              }
            }
          }
        }

        var prefixer;

        if (decl.prop === 'transition' || decl.prop === 'transition-property') {
          // Transition
          return _this.prefixes.transition.add(decl, result);
        } else if (decl.prop === 'align-self') {
          // align-self flexbox or grid
          var display = _this.displayType(decl);

          if (display !== 'grid' && _this.prefixes.options.flexbox !== false) {
            prefixer = _this.prefixes.add['align-self'];

            if (prefixer && prefixer.prefixes) {
              prefixer.process(decl);
            }
          }

          if (_this.gridStatus(decl, result) !== false) {
            prefixer = _this.prefixes.add['grid-row-align'];

            if (prefixer && prefixer.prefixes) {
              return prefixer.process(decl, result);
            }
          }
        } else if (decl.prop === 'justify-self') {
          // justify-self flexbox or grid
          if (_this.gridStatus(decl, result) !== false) {
            prefixer = _this.prefixes.add['grid-column-align'];

            if (prefixer && prefixer.prefixes) {
              return prefixer.process(decl, result);
            }
          }
        } else if (decl.prop === 'place-self') {
          prefixer = _this.prefixes.add['place-self'];

          if (prefixer && prefixer.prefixes && _this.gridStatus(decl, result) !== false) {
            return prefixer.process(decl, result);
          }
        } else {
          // Properties
          prefixer = _this.prefixes.add[decl.prop];

          if (prefixer && prefixer.prefixes) {
            return prefixer.process(decl, result);
          }
        }

        return undefined;
      }); // Insert grid-area prefixes. We need to be able to store the different
      // rules as a data and hack API is not enough for this

      if (this.gridStatus(css, result)) {
        insertAreas(css, this.disabled);
      } // Values


      return css.walkDecls(function (decl) {
        if (_this.disabledValue(decl, result)) return;

        var unprefixed = _this.prefixes.unprefixed(decl.prop);

        var list = _this.prefixes.values('add', unprefixed);

        if (Array.isArray(list)) {
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = list[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var value = _step3.value;
              if (value.process) value.process(decl, result);
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        }

        Value.save(_this.prefixes, decl);
      });
    }
    /**
     * Remove unnecessary pefixes
     */

  }, {
    key: "remove",
    value: function remove(css, result) {
      var _this2 = this;

      // At-rules
      var resolution = this.prefixes.remove['@resolution'];
      css.walkAtRules(function (rule, i) {
        if (_this2.prefixes.remove["@".concat(rule.name)]) {
          if (!_this2.disabled(rule, result)) {
            rule.parent.removeChild(i);
          }
        } else if (rule.name === 'media' && rule.params.includes('-resolution') && resolution) {
          resolution.clean(rule);
        }
      }); // Selectors

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        var _loop = function _loop() {
          var checker = _step4.value;
          css.walkRules(function (rule, i) {
            if (checker.check(rule)) {
              if (!_this2.disabled(rule, result)) {
                rule.parent.removeChild(i);
              }
            }
          });
        };

        for (var _iterator4 = this.prefixes.remove.selectors[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return css.walkDecls(function (decl, i) {
        if (_this2.disabled(decl, result)) return;
        var rule = decl.parent;

        var unprefixed = _this2.prefixes.unprefixed(decl.prop); // Transition


        if (decl.prop === 'transition' || decl.prop === 'transition-property') {
          _this2.prefixes.transition.remove(decl);
        } // Properties


        if (_this2.prefixes.remove[decl.prop] && _this2.prefixes.remove[decl.prop].remove) {
          var notHack = _this2.prefixes.group(decl).down(function (other) {
            return _this2.prefixes.normalize(other.prop) === unprefixed;
          });

          if (unprefixed === 'flex-flow') {
            notHack = true;
          }

          if (decl.prop === '-webkit-box-orient') {
            var hacks = {
              'flex-direction': true,
              'flex-flow': true
            };
            if (!decl.parent.some(function (j) {
              return hacks[j.prop];
            })) return;
          }

          if (notHack && !_this2.withHackValue(decl)) {
            if (decl.raw('before').includes('\n')) {
              _this2.reduceSpaces(decl);
            }

            rule.removeChild(i);
            return;
          }
        } // Values


        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = _this2.prefixes.values('remove', unprefixed)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var checker = _step5.value;
            if (!checker.check) continue;
            if (!checker.check(decl.value)) continue;
            unprefixed = checker.unprefixed;

            var _notHack = _this2.prefixes.group(decl).down(function (other) {
              return other.value.includes(unprefixed);
            });

            if (_notHack) {
              rule.removeChild(i);
              return;
            }
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
              _iterator5["return"]();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }
      });
    }
    /**
     * Some rare old values, which is not in standard
     */

  }, {
    key: "withHackValue",
    value: function withHackValue(decl) {
      return decl.prop === '-webkit-background-clip' && decl.value === 'text';
    }
    /**
     * Check for grid/flexbox options.
     */

  }, {
    key: "disabledValue",
    value: function disabledValue(node, result) {
      if (this.gridStatus(node, result) === false && node.type === 'decl') {
        if (node.prop === 'display' && node.value.includes('grid')) {
          return true;
        }
      }

      if (this.prefixes.options.flexbox === false && node.type === 'decl') {
        if (node.prop === 'display' && node.value.includes('flex')) {
          return true;
        }
      }

      if (node.type === 'decl' && node.prop === 'content') {
        return true;
      }

      return this.disabled(node, result);
    }
    /**
     * Check for grid/flexbox options.
     */

  }, {
    key: "disabledDecl",
    value: function disabledDecl(node, result) {
      if (this.gridStatus(node, result) === false && node.type === 'decl') {
        if (node.prop.includes('grid') || node.prop === 'justify-items') {
          return true;
        }
      }

      if (this.prefixes.options.flexbox === false && node.type === 'decl') {
        var other = ['order', 'justify-content', 'align-items', 'align-content'];

        if (node.prop.includes('flex') || other.includes(node.prop)) {
          return true;
        }
      }

      return this.disabled(node, result);
    }
    /**
     * Check for control comment and global options
     */

  }, {
    key: "disabled",
    value: function disabled(node, result) {
      if (!node) return false;

      if (node._autoprefixerDisabled !== undefined) {
        return node._autoprefixerDisabled;
      }

      if (node.parent) {
        var p = node.prev();

        if (p && p.type === 'comment' && IGNORE_NEXT.test(p.text)) {
          node._autoprefixerDisabled = true;
          node._autoprefixerSelfDisabled = true;
          return true;
        }
      }

      var value = null;

      if (node.nodes) {
        var status;
        node.each(function (i) {
          if (i.type !== 'comment') return;

          if (/(!\s*)?autoprefixer:\s*(off|on)/i.test(i.text)) {
            if (typeof status !== 'undefined') {
              result.warn('Second Autoprefixer control comment ' + 'was ignored. Autoprefixer applies control ' + 'comment to whole block, not to next rules.', {
                node: i
              });
            } else {
              status = /on/i.test(i.text);
            }
          }
        });

        if (status !== undefined) {
          value = !status;
        }
      }

      if (!node.nodes || value === null) {
        if (node.parent) {
          var isParentDisabled = this.disabled(node.parent, result);

          if (node.parent._autoprefixerSelfDisabled === true) {
            value = false;
          } else {
            value = isParentDisabled;
          }
        } else {
          value = false;
        }
      }

      node._autoprefixerDisabled = value;
      return value;
    }
    /**
     * Normalize spaces in cascade declaration group
     */

  }, {
    key: "reduceSpaces",
    value: function reduceSpaces(decl) {
      var stop = false;
      this.prefixes.group(decl).up(function () {
        stop = true;
        return true;
      });

      if (stop) {
        return;
      }

      var parts = decl.raw('before').split('\n');
      var prevMin = parts[parts.length - 1].length;
      var diff = false;
      this.prefixes.group(decl).down(function (other) {
        parts = other.raw('before').split('\n');
        var last = parts.length - 1;

        if (parts[last].length > prevMin) {
          if (diff === false) {
            diff = parts[last].length - prevMin;
          }

          parts[last] = parts[last].slice(0, -diff);
          other.raws.before = parts.join('\n');
        }
      });
    }
    /**
     * Is it flebox or grid rule
     */

  }, {
    key: "displayType",
    value: function displayType(decl) {
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = decl.parent.nodes[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var i = _step6.value;

          if (i.prop !== 'display') {
            continue;
          }

          if (i.value.includes('flex')) {
            return 'flex';
          }

          if (i.value.includes('grid')) {
            return 'grid';
          }
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
            _iterator6["return"]();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      return false;
    }
    /**
     * Set grid option via control comment
     */

  }, {
    key: "gridStatus",
    value: function gridStatus(node, result) {
      if (!node) return false;

      if (node._autoprefixerGridStatus !== undefined) {
        return node._autoprefixerGridStatus;
      }

      var value = null;

      if (node.nodes) {
        var status;
        node.each(function (i) {
          if (i.type !== 'comment') return;

          if (GRID_REGEX.test(i.text)) {
            var hasAutoplace = /:\s*autoplace/i.test(i.text);
            var noAutoplace = /no-autoplace/i.test(i.text);

            if (typeof status !== 'undefined') {
              result.warn('Second Autoprefixer grid control comment was ' + 'ignored. Autoprefixer applies control comments to the whole ' + 'block, not to the next rules.', {
                node: i
              });
            } else if (hasAutoplace) {
              status = 'autoplace';
            } else if (noAutoplace) {
              status = true;
            } else {
              status = /on/i.test(i.text);
            }
          }
        });

        if (status !== undefined) {
          value = status;
        }
      }

      if (node.type === 'atrule' && node.name === 'supports') {
        var params = node.params;

        if (params.includes('grid') && params.includes('auto')) {
          value = false;
        }
      }

      if (!node.nodes || value === null) {
        if (node.parent) {
          var isParentGrid = this.gridStatus(node.parent, result);

          if (node.parent._autoprefixerSelfDisabled === true) {
            value = false;
          } else {
            value = isParentGrid;
          }
        } else if (typeof this.prefixes.options.grid !== 'undefined') {
          value = this.prefixes.options.grid;
        } else if (typeof process.env.AUTOPREFIXER_GRID !== 'undefined') {
          if (process.env.AUTOPREFIXER_GRID === 'autoplace') {
            value = 'autoplace';
          } else {
            value = true;
          }
        } else {
          value = false;
        }
      }

      node._autoprefixerGridStatus = value;
      return value;
    }
  }]);

  return Processor;
}();

module.exports = Processor;