"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var Browsers = require('./browsers');

var vendor = require('./vendor');

var utils = require('./utils');
/**
 * Recursively clone objects
 */


function _clone(obj, parent) {
  var cloned = new obj.constructor();

  for (var _i = 0, _Object$keys = Object.keys(obj || {}); _i < _Object$keys.length; _i++) {
    var i = _Object$keys[_i];
    var value = obj[i];

    if (i === 'parent' && _typeof(value) === 'object') {
      if (parent) {
        cloned[i] = parent;
      }
    } else if (i === 'source' || i === null) {
      cloned[i] = value;
    } else if (Array.isArray(value)) {
      cloned[i] = value.map(function (x) {
        return _clone(x, cloned);
      });
    } else if (i !== '_autoprefixerPrefix' && i !== '_autoprefixerValues' && i !== 'proxyCache') {
      if (_typeof(value) === 'object' && value !== null) {
        value = _clone(value, cloned);
      }

      cloned[i] = value;
    }
  }

  return cloned;
}

var Prefixer =
/*#__PURE__*/
function () {
  _createClass(Prefixer, null, [{
    key: "hack",

    /**
     * Add hack to selected names
     */
    value: function hack(klass) {
      var _this = this;

      if (!this.hacks) {
        this.hacks = {};
      }

      return klass.names.map(function (name) {
        _this.hacks[name] = klass;
        return _this.hacks[name];
      });
    }
    /**
     * Load hacks for some names
     */

  }, {
    key: "load",
    value: function load(name, prefixes, all) {
      var Klass = this.hacks && this.hacks[name];

      if (Klass) {
        return new Klass(name, prefixes, all);
      } else {
        return new this(name, prefixes, all);
      }
    }
    /**
     * Clone node and clean autprefixer custom caches
     */

  }, {
    key: "clone",
    value: function clone(node, overrides) {
      var cloned = _clone(node);

      for (var name in overrides) {
        cloned[name] = overrides[name];
      }

      return cloned;
    }
  }]);

  function Prefixer(name, prefixes, all) {
    _classCallCheck(this, Prefixer);

    this.prefixes = prefixes;
    this.name = name;
    this.all = all;
  }
  /**
   * Find prefix in node parents
   */


  _createClass(Prefixer, [{
    key: "parentPrefix",
    value: function parentPrefix(node) {
      var prefix;

      if (typeof node._autoprefixerPrefix !== 'undefined') {
        prefix = node._autoprefixerPrefix;
      } else if (node.type === 'decl' && node.prop[0] === '-') {
        prefix = vendor.prefix(node.prop);
      } else if (node.type === 'root') {
        prefix = false;
      } else if (node.type === 'rule' && node.selector.includes(':-') && /:(-\w+-)/.test(node.selector)) {
        prefix = node.selector.match(/:(-\w+-)/)[1];
      } else if (node.type === 'atrule' && node.name[0] === '-') {
        prefix = vendor.prefix(node.name);
      } else {
        prefix = this.parentPrefix(node.parent);
      }

      if (!Browsers.prefixes().includes(prefix)) {
        prefix = false;
      }

      node._autoprefixerPrefix = prefix;
      return node._autoprefixerPrefix;
    }
    /**
     * Clone node with prefixes
     */

  }, {
    key: "process",
    value: function process(node, result) {
      if (!this.check(node)) {
        return undefined;
      }

      var parent = this.parentPrefix(node);
      var prefixes = this.prefixes.filter(function (prefix) {
        return !parent || parent === utils.removeNote(prefix);
      });
      var added = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = prefixes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var prefix = _step.value;

          if (this.add(node, prefix, added.concat([prefix]), result)) {
            added.push(prefix);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return added;
    }
    /**
     * Shortcut for Prefixer.clone
     */

  }, {
    key: "clone",
    value: function clone(node, overrides) {
      return Prefixer.clone(node, overrides);
    }
  }]);

  return Prefixer;
}();

module.exports = Prefixer;