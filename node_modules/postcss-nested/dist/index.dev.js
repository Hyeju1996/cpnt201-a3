"use strict";

var parser = require('postcss-selector-parser');

function parse(str, rule) {
  var nodes;
  var saver = parser(function (parsed) {
    nodes = parsed;
  });

  try {
    saver.processSync(str);
  } catch (e) {
    if (str.includes(':')) {
      throw rule ? rule.error('Missed semicolon') : e;
    } else {
      throw rule ? rule.error(e.message) : e;
    }
  }

  return nodes.at(0);
}

function replace(nodes, parent) {
  var replaced = false;
  nodes.each(function (i) {
    if (i.type === 'nesting') {
      var clonedParent = parent.clone();

      if (i.value !== '&') {
        i.replaceWith(parse(i.value.replace('&', clonedParent.toString())));
      } else {
        i.replaceWith(clonedParent);
      }

      replaced = true;
    } else if (i.nodes) {
      if (replace(i, parent)) {
        replaced = true;
      }
    }
  });
  return replaced;
}

function selectors(parent, child) {
  var result = [];
  parent.selectors.forEach(function (i) {
    var parentNode = parse(i, parent);
    child.selectors.forEach(function (j) {
      if (j.length) {
        var node = parse(j, child);
        var replaced = replace(node, parentNode);

        if (!replaced) {
          node.prepend(parser.combinator({
            value: ' '
          }));
          node.prepend(parentNode.clone());
        }

        result.push(node.toString());
      }
    });
  });
  return result;
}

function pickComment(comment, after) {
  if (comment && comment.type === 'comment') {
    after.after(comment);
    return comment;
  } else {
    return after;
  }
}

function createFnAtruleChilds(bubble) {
  return function atruleChilds(rule, atrule, bubbling) {
    var children = [];
    atrule.each(function (child) {
      if (child.type === 'comment') {
        children.push(child);
      } else if (child.type === 'decl') {
        children.push(child);
      } else if (child.type === 'rule' && bubbling) {
        child.selectors = selectors(rule, child);
      } else if (child.type === 'atrule') {
        if (child.nodes && bubble[child.name]) {
          atruleChilds(rule, child, true);
        } else {
          children.push(child);
        }
      }
    });

    if (bubbling) {
      if (children.length) {
        var clone = rule.clone({
          nodes: []
        });
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var child = _step.value;
            clone.append(child);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        atrule.prepend(clone);
      }
    }
  };
}

function pickDeclarations(selector, declarations, after, Rule) {
  var parent = new Rule({
    selector: selector,
    nodes: []
  });
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = declarations[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var declaration = _step2.value;
      parent.append(declaration);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  after.after(parent);
  return parent;
}

function atruleNames(defaults, custom) {
  var list = {};
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = defaults[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var _i = _step3.value;
      list[_i] = true;
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  if (custom) {
    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
      for (var _iterator4 = custom[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
        var i = _step4.value;
        var name = i.replace(/^@/, '');
        list[name] = true;
      }
    } catch (err) {
      _didIteratorError4 = true;
      _iteratorError4 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
          _iterator4["return"]();
        }
      } finally {
        if (_didIteratorError4) {
          throw _iteratorError4;
        }
      }
    }
  }

  return list;
}

module.exports = function () {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var bubble = atruleNames(['media', 'supports'], opts.bubble);
  var atruleChilds = createFnAtruleChilds(bubble);
  var unwrap = atruleNames(['document', 'font-face', 'keyframes', '-webkit-keyframes', '-moz-keyframes'], opts.unwrap);
  var preserveEmpty = opts.preserveEmpty;
  return {
    postcssPlugin: 'postcss-nested',
    Rule: function Rule(rule, _ref) {
      var _Rule = _ref.Rule;
      var unwrapped = false;
      var after = rule;
      var copyDeclarations = false;
      var declarations = [];
      rule.each(function (child) {
        if (child.type === 'rule') {
          if (declarations.length) {
            after = pickDeclarations(rule.selector, declarations, after, _Rule);
            declarations = [];
          }

          copyDeclarations = true;
          unwrapped = true;
          child.selectors = selectors(rule, child);
          after = pickComment(child.prev(), after);
          after.after(child);
          after = child;
        } else if (child.type === 'atrule') {
          if (declarations.length) {
            after = pickDeclarations(rule.selector, declarations, after, _Rule);
            declarations = [];
          }

          if (child.name === 'at-root') {
            unwrapped = true;
            atruleChilds(rule, child, false);
            var nodes = child.nodes;

            if (child.params) {
              nodes = new _Rule({
                selector: child.params,
                nodes: nodes
              });
            }

            after.after(nodes);
            after = nodes;
            child.remove();
          } else if (bubble[child.name]) {
            copyDeclarations = true;
            unwrapped = true;
            atruleChilds(rule, child, true);
            after = pickComment(child.prev(), after);
            after.after(child);
            after = child;
          } else if (unwrap[child.name]) {
            copyDeclarations = true;
            unwrapped = true;
            atruleChilds(rule, child, false);
            after = pickComment(child.prev(), after);
            after.after(child);
            after = child;
          } else if (copyDeclarations) {
            declarations.push(child);
          }
        } else if (child.type === 'decl' && copyDeclarations) {
          declarations.push(child);
        }
      });

      if (declarations.length) {
        after = pickDeclarations(rule.selector, declarations, after, _Rule);
      }

      if (unwrapped && preserveEmpty !== true) {
        rule.raws.semicolon = true;
        if (rule.nodes.length === 0) rule.remove();
      }
    }
  };
};

module.exports.postcss = true;